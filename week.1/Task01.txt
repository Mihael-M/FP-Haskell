
1-Правилното е mod x y, защото функцията mod е префиксна и написана така правилно взема своите параметри.
When is the use of an infix application of an otherwise prefix function permissive?
2-Само ако правим частично приложение, е позволено да ги приложим infixly.

3-Той е оператор за прилагане на функции чрез частично прилагане. 

4-Прочитаме тази функция като "след". Приема функция като левия параметър и израз като дясна страна.

5-Когато използвате $, той позволява по-кратък и по-четим синтаксис при композиране на функции или при извикването на функции с аргументи. Например, вместо да пишете f (g x), можем да използвате $ и да напишете f $ g x. Това прави кода по-четим и по-лесен за разбиране.

6-Функцията е дефинирана на фунцкионално ниво, когато е дефинирана заедно с други функции.
7-Като дефинираме фунцкиите на функционално ниво без непременно да се упоменавата нейните аргументи. Действията се извършват и създават чрез самите фунцкии.

8-Конструкция, която се използва за дефиниране на условия, които определят различни действия или стойности за функцията в зависимост от входните данни.
9-По-добре е да използваме guards.
10-По-добре е да използваме pattern matching.
11-Те са същото като Switch-case.

12-Резултатът се запазва във променлива(рекурсивна опашка) и рекурсивното извикване е част от израз.

13-Резултатът се съхранява като променлива, която се задава от различна функция. Променливата е резултат а функцията се нарича "helper".
Рекурсивното извикване не е част от израз и процесите са по-бързи от линейно рекурсивните.
14-Да възможно, е като например с функцията за факториел.

15- Най-добре е да го използваме, когато имаме pattern matching  и желаем да съберем няколко case в един без да ползваме име за конкретаната променлива.
16- Чрез нея правим проверки за някои специфични случаи, в които може програмата ни да попадне, като да и най-предпочитани пред guards и if-then-else.

17- 1) add :: Int -> Int -> Int
add x y = x + y, 
add2 :: Int -> Int
add2 = add 2
2) filterLessThan :: Int -> [Int] -> [Int]
filterLessThan x = filter (< x)
3) subtractFrom :: Int -> Int -> Int
subtractFrom x y = y - x
Why are brackets not needed when having prefix function application?
18- Не са задължителни, когато имаме префиксни функции, когато използваме функции е ляво-асоциативна операция.
19-Тези букви се използват за дефиниране на полиморфни функции, за това е по-добре да използваме x,y,z.
20-Винаги трябва да позлваме готови функции не да ги имплементираме, все пак за това някой вече се е мъчил да ги прави, да ги ползваме ние на готово.